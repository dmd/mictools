#!/usr/bin/env bash
set -euo pipefail

# Configuration you asked to hardcode:
CERT="/home/ddrucker/mictools/everything-mickey.pem"
KEY="/home/ddrucker/mictools/everything-mickey.pem"

# Find an available port in range 20000-60000
find_available_port() {
    local port
    local max_attempts=100
    local attempt=0

    # Check if ss command is available
    if ! command -v ss >/dev/null 2>&1; then
        printf "Error: 'ss' command not found (install iproute2)\n" >&2
        return 1
    fi

    while (( attempt < max_attempts )); do
        # Generate random port in range 20000-60000
        port=$((20000 + RANDOM % 40001))

        # Check if port is available (not listening)
        # Use grep with word boundary to match port at end of address field
        # Pattern matches :PORT followed by whitespace or end of line
        if ! ss -tuln | grep -qE ":${port}([[:space:]]|$)"; then
            echo "$port"
            return 0
        fi

        ((attempt++))
    done

    printf "Failed to find available port after %d attempts\n" "$max_attempts" >&2
    return 1
}

PORT=$(find_available_port)
if [[ -z "$PORT" ]]; then
    exit 1
fi

ADDR="0.0.0.0:$PORT"
printf "Using port %s\n" "$PORT" >&2

# Check for required commands
for cmd in rclone htpasswd pamtester; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        printf "Error: Required command '%s' not found\n" "$cmd" >&2
        exit 1
    fi
done

# Check for certificate and key files
if [[ ! -f "$CERT" ]]; then
    printf "Error: Certificate file not found: %s\n" "$CERT" >&2
    exit 1
fi
if [[ ! -f "$KEY" ]]; then
    printf "Error: Key file not found: %s\n" "$KEY" >&2
    exit 1
fi

# Default username: current user (you can set USERNAME environment var to override)
USERNAME="${USERNAME:-${USER:-$(whoami)}}"

# Helper to clean up temp file
cleanup() {
    [[ -n "${HTPASS_TMP:-}" && -f "$HTPASS_TMP" ]] && shred -u "$HTPASS_TMP" 2>/dev/null || true
}
trap cleanup EXIT

# Prompt for password (no echo)
printf "Password for %s: " "$USERNAME" >&2
# read -s will not put the password in the environment; it's in a shell var only
IFS= read -r -s PASSWORD
printf "\n" >&2

# Verify password with pamtester (as you specified)
# Security note: we pass password on stdin only; not on command line.
if ! printf "%s\n" "$PASSWORD" | pamtester --force-interactive login "$USERNAME" authenticate >/dev/null 2>&1; then
    printf "Authentication failed for user %s\n" "$USERNAME" >&2
    exit 1
fi

# Create a secure temporary htpasswd file (600)
HTPASS_TMP="$(mktemp --tmpdir rclone-htpasswd.XXXXXX)"
chmod 600 "$HTPASS_TMP"

# Create htpasswd entry using bcrypt (-B) and read password from stdin (-i)
# htpasswd -i reads the password from stdin; this avoids exposing it on command line.
# We feed the password once (htpasswd -i will read that single line and create the entry).
if ! printf "%s\n" "$PASSWORD" | htpasswd -i -B -c "$HTPASS_TMP" "$USERNAME"; then
    printf "Failed to write htpasswd file\n" >&2
    exit 1
fi

# Unset the shell variable holding the password as soon as it's no longer needed.
PASSWORD=''
unset PASSWORD

# Start rclone serve webdav using the htpasswd file.
# We do NOT pass --user/--pass here; rclone will use the htpasswd file for auth.
# This avoids showing the password in ps.
# Note: Not using exec so the cleanup trap can run when rclone exits
rclone serve webdav . \
    --addr "$ADDR" \
    --cert "$CERT" \
    --key "$KEY" \
    --htpasswd "$HTPASS_TMP"
